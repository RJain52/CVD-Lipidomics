---
title: "MIDUS data analysis"
author: "Raghav Jain"
date: "12/28/2022"
output:
  html_document:
    df_print: paged
---

# 1. Summary

*All data used in this script is randomly generated (FAKE data)*

We obtained anthropometric and lipidomic data on 874 Black and White females from the Midlife in the United States (MIDUS) study. We performed additional in-house oxylipid measurements on 196 of these samples. Our goal was to determine circulating signatures of high blood pressure (HBP; systolic BP\>120 or diastolic BP\>80) to gain insight into underlying CVD biology in females.

MIDUS data cannot be be published in a public format. Therefore, the data used in this script is randomly generated data. Requests for the original, real data used for analysis in our manuscript must be submitted to the MIDUS study.

Code for plots in our manuscript that is not in this script can be found in the SHOW analysis script.

For more information on methods, additional findings and the target population(s), please refer to our manuscript (updated link on Github page at RJain52/CVD-Lipidomics).

------------------------------------------------------------------------

# 2. Load packages and data

Please see 'Session info' for system requirements. For Mac, XQuartz is required to output pdf documents using 'Cairo' package. Note that all sections of the script are reliant on this section.

```{r}
# Run the packages twice to ensure installation and loading of packages
# may need to download 'xrun' package separately before loading this
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(ggpubr)){install.packages("ggpubr")}
if(!require(rstatix)){install.packages("rstatix")}
if(!require(ggsci)){install.packages("ggsci")}
if(!require(scales)){install.packages("scales")}
if(!require(Cairo)){install.packages("Cairo")}
if(!require(RColorBrewer)){install.packages("RColorBrewer")}
if(!require(ggrepel)){install.packages("ggrepel")}
if(!require(corrplot)){install.packages("corrplot")}
if(!require(VennDiagram)){install.packages("VennDiagram")}
if(!require(futile.logger)){install.packages("futile.logger")}
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")
if(!require(glmnet)){install.packages("glmnet")}
if(!require(tidymodels)){install.packages("tidymodels")}
if(!require(broom.mixed)){install.packages("broom.mixed")}
if(!require(vip)){install.packages("vip")}
if(!require(DescTools)){install.packages("DescTools")}
if(!require(networkD3)){install.packages("networkD3")}
if(!require(htmlwidgets)){install.packages("htmlwidgets")}
if(!require(webshot)){install.packages("webshot")}
if(!require(doParallel)){install.packages("doParallel")}

# Set default theme for plots
theme_set(theme_bw(base_size = 16, base_family = "Arial"))

# Set default color schemes
mypal <- pal_nejm(palette = c("default"))(8)
show_col(mypal)
midus_pal <- c("#0072B5FF", "#BC3C29FF")
palette_mc <- c("#7876B1CC", "#20854EFF")
midus_sc <- palette_mc
cortheme <- colorRampPalette(rev(c("#440154FF", "#481568FF", "#482677FF", "#453781FF", 
                               "#3F4788FF", "#39558CFF", "#32648EFF", "#2D718EFF",
                               "#287D8EFF", "#238A8DFF", "#1F968BFF","#20A386FF", 
                               "#29AF7FFF", "#3CBC75FF", "#56C667FF", "#74D055FF", 
                               "#94D840FF", "#B8DE29FF", "#DCE318FF", "#FDE725FF"
                               )))(75)
pie_Pal1 <- brewer.pal(9, "Set1") 

# Load data
my_data_indiv <- 
  read_csv("fake_data/MIDUS_FAKE_indiv.csv") # fake dataset for individual untargeted lipid species data
my_data_sum <- 
  read_csv("fake_data/MIDUS_FAKE_sums.csv")    # fake dataset for untargeted lipid class sums data
my_data_oxylipid <- 
  read_csv("fake_data/MIDUS_FAKE_oxylipid.csv") # fake dataset for targeted oxylipid analysis

# Code in factors with desired level hierarchy - important for plotting
# reorder the variable Diag_HBP so the hierarchy is Normal then High
my_data_indiv$Diag_HBP <- factor(my_data_indiv$Diag_HBP,
                                 levels = c("Normal", "High"))

# reorder the variable Race as above
my_data_indiv$Race <- factor(my_data_indiv$Race, 
                             levels = c("Caucasian", "African-American"))

# Rename to the White and Black to match survey questions asked 
levels(my_data_indiv$Race) <- c("White", "Black")

# Repeat the factor organization for oxylipid dataset
my_data_oxylipid$Diag_HBP <- factor(my_data_oxylipid$Diag_HBP,
                                 levels = c("Normal", "High"))
my_data_oxylipid$Race <- factor(my_data_oxylipid$Race, 
                             levels = c("Caucasian", "African-American"))
levels(my_data_oxylipid$Race) <- c("White", "Black")

# Use individual lipid species factor ordering for sum lipid data frame
my_data_sum$Diag_HBP <- my_data_indiv$Diag_HBP
my_data_sum$Race <- my_data_indiv$Race
```

------------------------------------------------------------------------

# 3. General plots

Code for plot types that were not described in the SHOW script. 

## Correlation plot 
Correlate anthropometric and cytokine data.

```{r, warning = FALSE}
# Subset out data
Z <- my_data_indiv |>
  select(Race, Age:`IL-8 (pg/mL)`)

# Select population (Black or White)
C <- Z |>
  filter(Race == "Black") |>    # Black or White
  select(!Race)

#calculate the spearman correlation coefficient for each pair of variables in the data frame 'C'
M1 <- cor(C, method = "spearman", 
          use = "pairwise.complete.obs") # only participants with values for each correlating variable used

#calculate p-value for spearman correlation coefficient for each pair of variables in the data frame 'C'
M2 <- cor.mtest(C, method = "spearman", 
                conf.level = 0.95,               # 95% conf level;p<0.05 considered significant
                use = "pairwise.complete.obs")   


CairoPDF(file = "output/Fake_Black_corr_plot.pdf",
         width = 12, height = 12)
 # This code is used to create a correlation plot of the MIDUS data, using the corrplot package
  corrplot(M1, p.mat = M2$p, # Create plot; M1 data frame contains spearman coefficients and M2 has p-values
          method = "circle", # Use circles to represent size and direction of correlation
          type = "lower",    # Orientation of triangle for plot
          insig = "blank",   # Whether correlations with p<0.05 should be plotted (here they are not)
          tl.col = "black",  # Color text
          tl.cex = 0.8,      # size of text
          number.cex = 0.5,  # size of number
          tl.srt = 45,       # size of tiles
          title = "MIDUS - Black clinical",    # plot title
          col = cortheme,    # color palette
          mar = c(0,0,1,0)   # margins of plot
          )
dev.off()
```

## Pie Chart
Description of measured lipids containing arachidonic acid (20:4).
```{r}
# Subset columns of interest from individual lipid data frame
Z <- my_data_indiv |>
  select(Simcox_ID, Race, Diag_HBP, 
         grep("20:4", names(my_data_indiv)    # pull all columns with 20:4 in column name
              )
         )

# Subset columns of interest from sum lipid data frame
Z1 <- my_data_sum |>
  select(Simcox_ID, 
         grep("20:4", names(my_data_sum)
              )
         )

# Merge subsetted columns
Z2 <- left_join(Z, Z1, by = 'Simcox_ID')

# Edit lipid nomenclature to match SHOW naming
names(Z2) <- gsub("/", "_",names(Z2))
names(Z2) <- gsub("PE O-", "EtherPE ",names(Z2))
names(Z2) <- gsub("PE P-", "EtherPE ",names(Z2))
names(Z2) <- gsub("-", "_",names(Z2))

# Replace NA with 0
Z2[is.na(Z2)] <- 0

# Change data to long form
mdat <- Z2 |> pivot_longer(!c(Simcox_ID, Race, Diag_HBP),
                           names_to = "Lipid", 
                           values_to = "value")

# Split lipid name by acyl chain and clean up names
mdat_FA <- str_split_fixed(mdat$Lipid, "_", 2)
mdat2 <- cbind(mdat, mdat_FA)
mdat2_FA1 <- mdat2[,1:6]
mdat2_FA2 <- mdat2[,c(1:5,7)]

names(mdat2_FA1)[6] <- "FA"
names(mdat2_FA2)[6] <- "FA"

mdat2_FA1$FA <- gsub(".* ", "", mdat2_FA1$FA)

# This is the working dataset with original lipid and acyl chain signal attached
mdat3 <- rbind(mdat2_FA1, mdat2_FA2)

# Filter out the signal of all non-arachidonic acid acyl chains
mdat4 <- mdat3[mdat3$FA == '20:4',]

# Edit lipid name to include subclass info only
mdat4$Lipid <- gsub(" .*", "", mdat4$Lipid) # Remove all alphanumeric text after the first space

# Sum up acyl chain values keeping the ID and lipid name info as grouping variables
mdat4 <- mdat4 |>
  group_by(Simcox_ID, Lipid) |> 
  summarise(value = sum(value)) |>
  ungroup()
  
# Get the average arachidonic acid intensity contained in each lipid subclass in the dataset
mdat4 <- mdat4 |>
  group_by(Lipid) |> 
  summarise(value = mean(value)) |>
  ungroup()

# Set color scheme for each lipid class in the dataset (needs to match with SHOW as well)
# "CE"      "DAG"     "EtherPE" "FA"      "LPC"     "LPE"     "PC"      "PE"      "PI"      "TAG" 
pie_pal <- c("#E41A1C", "black", "#4DAF4A", "#984EA3", "#91D1C2B2", # CE DAG EtherPE FA LPC
             "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999") # LPE PC PE PI TG

# Calculate percentage of total intensity for each subclass
mdat4$percent <- round(100*mdat4$value/sum(mdat4$value), 2)

# Edit pie chart label
mdat4$label <- paste0(mdat4$Lipid, " (", 
                      mdat4$percent,
                      "%)")

CairoPDF(file = "output/Fake_MIDUS_ARA_intensity_pie.pdf",
         height=8, width = 8)
# create pie chart to plot proportion of each subclass contributing to total 20:4 signal
  pie(mdat4$value,          # variable to calculate proportions
      labels = mdat4$label, # label of each slice
      col = pie_pal,        # color palette to use
      main = "MIDUS 20:4 intensity across lipids",  # plot title
      border="black")       # plot outline
dev.off()
```

------------------------------------------------------------------------

# 4. Multiple linear regressions

## MIDUS multiple linear regressions
A reminder that the dataset used for these analyses presented here is NOT the same as reported in our manuscript. The code is presented here as a direct example of how original data was handled and obtaining original data will yield the same results as in the manuscript. 
```{r}
# Subset TAGs containing identified acyl chains from sum lipid data frame
Y <- my_data_sum |>
  select(Simcox_ID, `TAG 42:0-16:0`:`TAG 60:11-22:6`)

# Subset key variables for regressions from individual lipid data frame
Z <- my_data_indiv |>
  select(Simcox_ID, `Systolic BP`, Race, Age, `WC (cm)`, 
         `CRP (ug/mL)`, `HDL (mg/dL)`, `Total Chol (mg/dL)`, 
         HbA1c, `CE 12:0`:`TAG 60:11`)

# Combine individual and sum lipid data frames by 'Simcox_ID'
Z <- left_join(Z, Y, by = "Simcox_ID")

# Remove 'Simcox_ID' variable
Z <- Z |> select(!Simcox_ID)
```
The following process is identical to how multiple linear regressions were conducted in the SHOW script. Please refer to that script for more heavily annotated code. 
```{r}
y_var <- Z$`Systolic BP`

race_var <- Z$Race
Age_var <- scale(log2(Z$Age), center = TRUE, scale = TRUE)
WC_var <- scale(log2(Z$`WC (cm)`), center = TRUE, scale = TRUE)
CRP_var <- scale(log2(Z$`CRP (ug/mL)`), center = TRUE, scale = TRUE)
Hb_var <- scale(log2(Z$HbA1c), center = TRUE, scale = TRUE)
HDL_var <- scale(log2(Z$`HDL (mg/dL)`), center = TRUE, scale = TRUE)
Chol_var <- scale(log2(Z$`Total Chol (mg/dL)`), center = TRUE, scale = TRUE)

lipid <- as.character()

beta_y_int <- as.numeric()
beta_AfAm <- as.numeric()
beta_Age <- as.numeric()
beta_WC <- as.numeric()
beta_CRP <- as.numeric()
beta_Hb <- as.numeric()
beta_HDL <- as.numeric()
beta_Chol <- as.numeric()
beta_lipid <- as.numeric()

p_y_int <- as.numeric()
p_AfAm <- as.numeric()
p_Age <- as.numeric()
p_WC <- as.numeric()
p_CRP <- as.numeric()
p_Hb <- as.numeric()
p_HDL <- as.numeric()
p_Chol <- as.numeric()
p_lipid <- as.numeric()

adj_r_sq <- as.numeric()

for (i in 9:ncol(Z)) {
  x_var <- scale(log2(Z[,i]), center = TRUE, scale = TRUE)
  my_lm <- lm(y_var ~ race_var + Age_var + WC_var + CRP_var + Hb_var + HDL_var + Chol_var + x_var)
  
  lipid[i] <- names(Z)[i]
        
  beta_y_int[i] <- summary(my_lm)$coefficients[1,1]
  beta_AfAm[i] <- summary(my_lm)$coefficients[2,1]
  beta_Age[i] <- summary(my_lm)$coefficients[3,1]
  beta_WC[i] <- summary(my_lm)$coefficients[4,1]
  beta_CRP[i] <- summary(my_lm)$coefficients[5,1]
  beta_Hb[i] <- summary(my_lm)$coefficients[6,1]
  beta_HDL[i] <- summary(my_lm)$coefficients[7,1]
  beta_Chol[i] <- summary(my_lm)$coefficients[8,1]
  beta_lipid[i] <- summary(my_lm)$coefficients[9,1]
        
  p_y_int[i] <- summary(my_lm)$coefficients[1,4]
  p_AfAm[i] <- summary(my_lm)$coefficients[2,4]
  p_Age[i] <- summary(my_lm)$coefficients[3,4]
  p_WC[i] <- summary(my_lm)$coefficients[4,4]
  p_CRP[i] <- summary(my_lm)$coefficients[5,4]
  p_Hb[i] <- summary(my_lm)$coefficients[6,4]
  p_HDL[i] <- summary(my_lm)$coefficients[7,4]
  p_Chol[i] <- summary(my_lm)$coefficients[8,4]
  p_lipid[i] <- summary(my_lm)$coefficients[9,4]
    
  adj_r_sq[i] <- summary(my_lm)$adj.r.sq
}

final_data <- cbind(lipid, beta_y_int, beta_AfAm, beta_Age,
                    beta_WC, beta_CRP, beta_Hb, beta_HDL, beta_Chol, beta_lipid, 
                    p_y_int, p_AfAm, p_Age, p_WC, p_CRP, p_Hb, p_HDL, p_Chol, p_lipid,
                    adj_r_sq)

final_data <- as_tibble(final_data)
final_data <- final_data |> drop_na()
final_data[,2:ncol(final_data)] <- sapply(final_data[,2:ncol(final_data)],
                                          as.numeric) 

summary(lm(y_var ~ race_var + Age_var + WC_var + CRP_var + Hb_var + HDL_var + Chol_var))
```
The plot will not be outputted as the results were generated using random data.
```{r}
reg_plot <- final_data
reg_plot$p_lipid_fdr<- p.adjust(reg_plot$p_lipid, method = 'fdr')

reg_plot$sig_lipid <- ifelse(reg_plot$p_lipid_fdr < 0.15, 
                             "YES", "NO")

reg_plot$useful <- ifelse(reg_plot$adj_r_sq > 0.1816 & reg_plot$p_lipid_fdr < 0.15,
                          "YES", "NO")

reg_plot$delabel <- NA
reg_plot$delabel <- ifelse(reg_plot$useful == "YES",
                           reg_plot$lipid, NA)

toMatch <- c("20:4", "18:2", "22:4")
  
reg_plot$delabel <- ifelse(grepl(paste(toMatch,collapse="|"), 
                             reg_plot$delabel),reg_plot$delabel,NA)

reg_plot$p_lipid <- (-log10(reg_plot$p_lipid))
p0 <- ggplot(data=reg_plot, aes(x=beta_lipid, y=p_lipid, 
                                col=useful)) +
        geom_point(alpha = 0.5) + 
        scale_x_continuous(limits = c(-2.5, 3.0)) +
        scale_y_continuous(limits = c(0, 5.5), expand = c(0.01,0)) +
        scale_color_manual(values=c("#BC3C29FF", "grey70"), 
                         name = "Lipid term (FDR)",
                         breaks = c("YES", "NO"), 
                         labels = c("q<0.15", "q>0.15")) +
        geom_text_repel(aes(label=delabel), color = "black", 
                        segment.color = "#000000B2",
                        min.segment.length = 0, segment.size = 0.2,
                        size = 4, fontface = "bold", family = "Arial",
                        box.padding = 0.5, max.overlaps = Inf) +
        ggtitle("MIDUS Regressions - MLR") +
        ylab(expression(bold("-log"["10"]*"(p-value)"))) +
        xlab(expression(bold("Beta-coefficient"))) +
        theme_bw(base_size = 16, base_family = "Arial") + 
        theme(legend.position = "right",
              text = element_text(face="bold"), 
              axis.text = element_text(colour = "black"))
```

## Venn Diagram 
Comparing significant regression lipid species from SHOW and MIDUS (positive predictors of systolic BP only).
```{r}
# Retrieve lipids significantly associated with systolic BP in the respective studies 
MLR_lipids <- read_csv("fake_data/MLR_Venn.csv")
MIDUS_lipids <- na.omit(as.vector(MLR_lipids$MIDUS_lipids))
SHOW_lipids <- na.omit(as.vector(MLR_lipids$SHOW_lipids))

# Color scheme for Venn diagram
myCol_fill <- c("#E18727B2", "#BC3C29B2")
myCol_text <- c("#E18727FF", "#BC3C29FF")

# Make venn diagram
v <-  venn.diagram(x = list(SHOW_lipids, MIDUS_lipids),
             category.names = c("SHOW", "MIDUS"),   # title of each category in Venn diagram
             main = "Predictive 18:2, 20:4 and 22:4 containing lipids", # plot title
             compression = "lzw",        # image compression
             fontfamily = "Arial",       # text font
             col = myCol_fill, fill = alpha(myCol_fill, 0.7), # fill colors
             cat.col = myCol_text,           # text colors
             cat.fontface = "bold" , cat.cex = 1, # font face and size
             cat.fontfamily = "Arial",            
             filename = NULL, resolution = 600,   # image resolution
             output = T)

CairoPDF(file = "output/MIDUS_Venn_MLR.pdf")
  grid.draw(v)
dev.off()
```

------------------------------------------------------------------------

# 5. Lasso regression
Code used for lasso machine learning regression to identify the most important predictors of systolic BP in the MIDUS data set.
```{r}
# Subset variables
Z <- my_data_indiv |>
  select(Simcox_ID, `Systolic BP`, Race, Age, `WC (cm)`, HbA1c, 
         `Total Chol (mg/dL)`, `HDL (mg/dL)`, `CRP (ug/mL)`, 
         `CE 12:0`:`SM 26:1`)  # Exclude TAG variables as they will be taken from sum lipid data

# Drop participants with key data missing
Z <- Z |> 
  na.omit(HbA1c, `WC (cm)`)

# Add sum lipid TAG variables as they have acyl chain information
Z <- left_join(Z,
               my_data_sum |>
                 select(Simcox_ID,
                        `TAG 42:0-16:0`:`TAG 60:11-22:6`
                        ),
               by = "Simcox_ID")

# log2 transform all continuous independent variables
Z <- Z |>
  mutate(across(Age:`TAG 60:11-22:6`, log2)
         ) |>
  select(-Simcox_ID)

# Replace NA values with 0 (should only be replacing MS-based lipid variables)
Z <- Z |>
  replace(is.na(Z), 0)
  
# Create a grouping variable for Race AND BP status
Z$ID <- interaction(Z$Race, 
                    Z$`Systolic BP`>120) # stratification variable for data split

# Change Race to a dummy variable where 0 = White, 1 = Black
Z$Race <- ifelse(Z$Race == "White", 0, 1) 
```

Run lasso regression predicting systolic BP to identify the variables most strongly associated with blood pressure.
```{r}
# For reproducibility
set.seed(125)                     

# Split data into train and test sets
X_split <- initial_split(Z, 
                         prop = 7/10,  # 70% data will be training, 30% will be test
                         strata=ID     # Keep the 70/30 split within groups as well (Race and BP)
                         )

# Create data frames for the two sets:
train_data <- training(X_split)
test_data  <- testing(X_split)

# Create recipe for training set
Xtrain_rec <- recipe(`Systolic BP` ~., train_data) |>   # Regression formula
  update_role(ID, new_role = "ID") |>                   # Exclude stratification variable from calculation
  step_zv(all_numeric(), -all_outcomes()) |>            # Ensure all predictors are numeric
  step_normalize(all_predictors())                      # Normalize and scale all predictors

# This prevents ID from being used in the regression
Xtrain_prep <- Xtrain_rec |>
  prep(strings_as_factors = FALSE)   

# Save mean and sd used to normalize training data set in an object
norm_objtrain <- prep(Xtrain_prep, 
                      training = train_data)

# Create workflow with recipe
wflow <- 
  workflow() |>
  add_recipe(Xtrain_rec)

wflow

# Create model (lasso specified by mixture = 1); the lambda parameter will be tuned with train set
lasso_mod <- linear_reg(penalty = tune(), # Specify linear regression will be used
                        mixture = 1) |>   # alpha = mixture; 0 = ridge, 1 = lasso; penalty = lambda
  set_engine("glmnet")              

# Create a grid to be populated with values of lambda for tuning
lambda_grid <- grid_regular(penalty(), 
                            levels = 100)

# Use all cores to speed up calculation
doParallel::registerDoParallel()
set.seed(523) # for reproducibility

# set tune with cross validation specified
lasso_grid <- tune_grid(
  wflow |> add_model(lasso_mod),                          # specify lasso model using defined workflow
  resamples = vfold_cv(train_data, v = 5, repeats = 10),  # use cross fold validation
  grid = lambda_grid                                      # populate the grid
)

# View training set lambda tuning
lasso_grid |>
  collect_metrics()

# Visualize how well lambda was tuned over the cross validation
lasso_grid |>
  collect_metrics() |>
  ggplot(aes(log(penalty), mean, color = .metric)) +   # plot penalty (lambda value) over the iterations
  geom_line() +
  facet_wrap(~.metric, scales = "free", nrow = 2) +    # evaluate error metric next to penalty
  theme(legend.position = "none")                      # error should be at lowest with best lambda value

# Evaluate error for each data point in best model; Tight error = good
lasso_grid |>
  collect_metrics() |>
  ggplot(aes(penalty, mean, color = .metric)) +
  geom_errorbar(aes(
    ymin = mean - std_err,
    ymax = mean + std_err
  ),
  alpha = 0.5
  ) +
  geom_line(size = 1.5) +
  facet_wrap(~.metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Choose the best penalty/lambda value based on cross-fold validation
best_lambda <- lasso_grid |>
  select_best("rmse",           
              maximize = F
              )  
# Different metrics can be prioritized to determine best lambda
best_rsq <- lasso_grid |>
              select_best("rsq")
# Same model has best RMSE and R2

# Final workflow with the lambda value set after tuning
# Run lasso regression 
final_lasso <- finalize_workflow(
  wflow |> add_model(lasso_mod), 
  best_lambda)

# Plot variables in the final model
vip_plot <- final_lasso |>           # Specify the final model
  fit(train_data) |>                 # Specify the dataset (training)
  extract_fit_parsnip() |>           # Extracts key metrics of model
  vi(lambda = best_lambda$penalty) |>  # Specifies lambda value
  filter(Importance > 0) |>           # Prevent unimportant variables from being plotted
  mutate(
    Importance = abs(Importance),      # Plot importance regardless of prediction sign
    Variable = fct_reorder(Variable, Importance) # Order variables from high to low importance for plot
  ) |>
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +  # Plot variable name and importance
  geom_col() +       # bar chart
  scale_fill_manual(name = "Beta_coeff", labels = c("NEG", "POS"), # Color is sign of direction
                    values = c("#7876B1CC", "#20854EFF")) +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL) + 
  ggtitle("Variable Importance Plot - Lasso") +
  theme_bw(base_size = 10, base_family = "Arial")

# View plot
vip_plot

# View metrics of final model
last_fit(final_lasso,
         X_split) |>
  collect_metrics()

# Create object with final model used on the training date
train_fit <- final_lasso |>
  fit(data = train_data)

# Lipid coefficient results from lasso model 
trained_mod_beta <- train_fit |>           
  extract_fit_parsnip() |>
  pluck("fit") |>            # extract key variable info from the model
  coef(s = best_lambda$penalty) |>
  as.matrix() |>             # make a matrix, then tibble of the data for viewing
  as_tibble(rownames = 'id') |>
  set_names("predictor", "beta") |> # set column names
  filter(beta != 0)                 # only variables with predictive value are retained

# Calculate training dataset mean average error (MAE)
train_MAE <- predict(train_fit, Xtrain_rec$template) |>
        bind_cols(train_data |>
                    select(`Systolic BP`, Race)
                  )
train_MAE$error = abs(train_MAE$`Systolic BP` - train_MAE$.pred)
mean(train_MAE$error) # This is the metric to calculate and compare the test data regression to

# Now use the tuned, final model on the test data set
# Apply same normalization used for training set on test data
Xtest_rec <- recipe(`Systolic BP` ~., test_data) |>
  update_role(ID, new_role = "ID") |>                  # Exclude stratification variable from calculation
  step_zv(all_numeric(), -all_outcomes()) |>           
  step_normalize(all_predictors())

# Apply trained model to test data
test_MAE <- predict(train_fit, Xtest_rec$template) |>
        bind_cols(test_data |>
                    select(`Systolic BP`, Race)
                  )

# Calculate test MAE
test_MAE$error = abs(test_MAE$`Systolic BP`- test_MAE$.pred)
mean(test_MAE$error)

# Save predictions from the training and test data modeling
train_final <- train_MAE
test_final <- test_MAE

# Recode race variables as factors
train_final$Race <- ifelse(train_final$Race == 0,
                           "White", "Black")
test_final$Race <- ifelse(test_final$Race == 0,
                          "White", "Black")

train_final$Race <- factor(train_final$Race,
                           levels = c("White", "Black"))
test_final$Race <- factor(test_final$Race,
                          levels = c("White", "Black"))

# Plot the predicted and actual systolic BP from the training data set
p0 <- train_final |>
  ggplot(aes(x = `Systolic BP`, y = .pred, color = Race)) +
  geom_jitter() +
  stat_smooth(method = "lm", se = F, fullrange = T) +   # Add a line of best fit to data for each Race
  stat_cor(method = "spearman",
           label.x = min(train_final$`Systolic BP`),
           p.accuracy = 0.001, r.accuracy = 0.01,
           na.rm = T) +
  scale_color_manual(name = "Race",
                     labels = c("White", "Black"),
                     values = c("#7876B1CC","#20854EFF")
                     ) +
  xlab("Observed") +
  ylab("Predicted") +
  ggtitle("MIDUS Lasso - Training Data Systolic") +
  theme_bw(base_size = 14, 
           base_family = "Arial",
           base_line_size = 1.5)

# Create a plot for the test data set 
p1 <- test_final |>
  ggplot(aes(x = `Systolic BP`, y = .pred, color = Race)) +
  geom_jitter() +
  stat_smooth(method = "lm", se = F, fullrange = T) +
  stat_cor(method = "spearman",
           label.x = min(train_final$`Systolic BP`),
           p.accuracy = 0.001, r.accuracy = 0.01,
           na.rm = T) +
  scale_color_manual(name = "Race", 
                     labels = c("White", "Black"),
                     values = c("#7876B1CC","#20854EFF")) +
  xlab("Observed") +
  ylab("Predicted") +
  ggtitle("MIDUS Lasso - Test Data Systolic") +
  theme_bw(base_size = 14,
           base_family = "Arial",
           base_line_size = 1.5)

CairoPDF(file = "output/MIDUS_Fake_lasso_vip_plot.pdf",
         height = 8, width = 8)
  print(vip_plot)
dev.off()

CairoPDF(file = "output/MIDUS_Fake_train_lasso.pdf",
         height = 8, width = 8)
  print(p0)
dev.off()

CairoPDF(file = "output/MIDUS_Fake_test_lasso.pdf",
         height = 10, width = 10)
  print(p1)
dev.off()
```
The VIP and scatter plots are non-informative as the data used is randomly generated and there is no relationship between variables.
------------------------------------------------------------------------

# 6. Oxylipid analysis

Load sheet containing info on oxylipids and a dataset with fake values for oxylipids on 196 females.
```{r}
# Oxylipid info
class_info <- read_csv("fake_data/oxylipid_info.csv",
                    show_col_types = F)

# Create variables describing origin of oxylipid (enzyme and fatty acid) into factors
class_info$Enzyme1 <- factor(class_info$Enzyme1,
                              levels = c("COX", "CYP450", "LOX", "ROS", "None")
                              )
class_info$FA <- factor(class_info$FA,
                        levels = c("LA", "GLA", "ALA", "Mead", "DGLA",
                                   "ARA", "EPA", "DHA")
                        )
```
Data set with free oxylipid measurements normalized to the appropriate fatty acid values based on path of synthesis.
```{r}
# Subset key data
Y <- my_data_oxylipid |> 
  select(Simcox_ID, Diag_HBP, Race,
         tetranor_PGFM:DGLA)

# Replace NA with 0
Y[is.na(Y)] <- 0

# Make data long-form
X <- Y |>
  pivot_longer(cols = -c(Simcox_ID, Diag_HBP, Race),
               names_to = "Oxylipid", 
               values_to = "value")

# Relate oxylipid to FA of origin
Z <- left_join(X, class_info, 
               by = "Oxylipid", 
               keep = F)

# Create new column 'val1' with the FA measurement with respect to each individual and oxylipid 
Z <- Z |>
  group_by(Simcox_ID) |>
  mutate(val1 = case_when(FA == 'ARA' ~ value[Oxylipid == "AA"], 
                          FA == 'EPA' ~ value[Oxylipid == "EPA"],
                          FA == 'DHA' ~ value[Oxylipid == "DHA"],
                          FA == 'LA' ~ value[Oxylipid == "LA"],
                          FA == 'ALA' ~ value[Oxylipid == "ALA"],
                          FA == 'DGLA'  ~ value[Oxylipid == "DGLA"],
                          FA == 'GLA' | FA == 'Mead' ~ 1 )
         ) |>
  ungroup()

# Normalize oxylipids to FA measurements
ox_norm <- Z |>
  mutate(norm_val = value/val1)  
```

## Forest plot
Create Forest plot of Spearman correlations between oxylipids and systolic BP [90% CI] for each Race. This plot uses free oxylipid values, NOT FA normalized values.
```{r}
# Subset data of interest
mdat <- my_data_oxylipid |> 
  filter(Race == "White") |>   # Black or White
  select(Simcox_ID, `Systolic BP`,
         tetranor_PGFM:DGLA) 

# Create variables to store rho and bounds of confidence interval
srho <- as.numeric()
low_ci <- as.numeric()
high_ci <- as.numeric()

# Individually correlate each oxylipid with systolic BP and save metrics through iteration
for (i in 3:ncol(mdat)) {
  xvar <- mdat$`Systolic BP` # always BP values
  yvar <- mdat[,i]           # oxylipid values; changes with each iteration
  names(yvar)[1] <- "lipid"
  
  #Correlation; output saved
  sro_ci <- SpearmanRho(x = xvar,
            y = yvar$lipid,
            use = "complete.obs",
            conf.level = 0.90)
  
  # Extract key metrics
  srho[i] <- sro_ci[1]
  low_ci[i] <- sro_ci[2]
  high_ci[i] <- sro_ci[3]
}

# Create data frame with correlation metrics for all oxylipids
mdat2 <- data.frame("Oxylipid" = names(mdat), 
                    "rho" = srho,
                    "lower" = low_ci,
                    "upper" = high_ci) |>
  na.omit()

# Create binary variable to specify if 0 is contained in the CI
mdat2$remove <- ifelse(mdat2$lower < 0 & mdat2$upper > 0, T, F)

# Retain variables without 0 in CI
mdat2 <- mdat2 |>
  filter(remove == F)

# Create variable with direction of correlation
mdat2$sign <- ifelse(mdat2$rho > 0, 
                     "Pos", "Neg")

# Add in oxylipid info
mdat2 <- mdat2 |> left_join(class_info,
                            by = "Oxylipid")

# Create data frame to specify color to be used for each FA-oxylipid relationship
lab_cols <- data.frame(FA = c("ARA", "DHA", "ALA", "LA", "EPA"),
                       FA_col = c("tan3", "lightsalmon", "yellowgreen", 
                                    "firebrick4", "mediumorchid1"))
# Add color info to data frame
mdat2 <- mdat2 |> 
  left_join(lab_cols,
            by = "FA", 
            keep = F)

# Remove oxylipids not generated from enzymes
mdat2 <- mdat2 |>
  filter(!Enzyme1 == "None") |>
  droplevels()

# Create plot
p0 <- mdat2 |>
  ggplot(aes(y=Oxylipid, x=rho,        # x-axis is rho, y-axis is oxylipid name
             color = FA,               # bar colors designate fatty acid
             xmin=lower, xmax=upper)   # set error bar limits
         ) +
  geom_point() +                       # add dots for rho
  geom_errorbarh(height=.4) +          # add error bar
  geom_vline(xintercept=0,             # create line to designate 0
             linetype = 'dashed', 
             color = "grey10", size = 1) +
  scale_color_manual("Precursor",
                     values = mypal) +
  scale_x_continuous(limits = c(-0.4, 0.4)) +
  xlab("Rho (90% CI)") +
  ylab("Oxylipid") +
  ggtitle("White females", 
          subtitle = "Spearman correlations with Systolic blood pressure") +
  theme(
  plot.title = element_text(hjust = 0.5),
  plot.subtitle = element_text(hjust = 0.5, size = 12)
  )

CairoPDF(file = "output/MIDUS_Fake_White_Forest.pdf",
         height = 10, width = 10)
  print(p0)
dev.off()
```

## Interactions
MLR using race and oxylipid term interaction: 

Systolic = Age + Hba1c + CRP + WC + total cholesterol + HDL + Race + lipid + Race*lipid

This formally tests whether oxylipid associations with systolic BP is different based on Race. 
```{r}
# Use FA normalized data set
inter_data <- ox_norm |>
  select(Simcox_ID:Oxylipid, norm_val)

# Make data wide form
inter_data <- inter_data |>
  pivot_wider(names_from = Oxylipid,
              values_from = norm_val)
```
This code is essentially the same as for the untargeted lipidomics multiple linear regression section.
```{r}
# Replace 0 values with NA
X[X==0] <- NA

y_var <- X$`Systolic BP`

race_var <- X$Race
Age_var <- scale(log2(X$Age), center = TRUE, scale = TRUE)
WC_var <- scale(log2(X$`WC (cm)`), center = TRUE, scale = TRUE)
Chol_var <- scale(log2(X$`Total Chol (mg/dL)`), center = TRUE, scale = TRUE)
HDL_var <- scale(log2(X$`HDL (mg/dL)`), center = TRUE, scale = TRUE)
CRP_var <- scale(log2(X$`CRP (ug/mL)`), center = TRUE, scale = TRUE)
Hb_var <- scale(log2(X$HbA1c), center = TRUE, scale = TRUE)

# Oxylipid to test 
x_var <- scale(log2(X$LTB3), 
               center = TRUE, 
               scale = TRUE)

# Below is are the various regressions tested

# Base regression
my_lm <- lm(y_var ~ Age_var + WC_var + CRP_var + Hb_var + Chol_var + HDL_var + race_var)
summary(my_lm) 

# Regression with oxylipid but no interaction
my_lm <- lm(y_var ~ Age_var + WC_var + CRP_var + Hb_var + Chol_var + HDL_var + race_var + x_var)
summary(my_lm)$coefficients[9,4] # lipid term

# Regression with interaction between race and oxylipid
my_lm <- lm(y_var ~ Age_var + WC_var + CRP_var + Hb_var + Chol_var + HDL_var + race_var*x_var)
summary(my_lm)$adj.r.sq    # adjusted R-squared term
```

## Sankey plot
Create a Sankey plot to visualize the relationship between measured oxylipids, enzymatic pathways, and fatty acid precursor.
```{r}
# Subset data
Z <- class_info |> 
  select(Oxylipid, Enzyme1, FA) |>
  filter(!Enzyme1 == "None")  # remove fatty acids

# Rename all oxylipid species to generic 'Oxylipid'
Z$Oxylipid <- "Oxylipid"

# Make data long-form but use row-number to keep track of oxylipid-enzyme-FA relationship
links.df <- Z |>
  mutate(row = row_number()) |>        # Row is the first 'node'                                  
  pivot_longer(cols = -row, 
               names_to = "column", 
               values_to = "source")

# Create relationship between all variables
links.df <- links.df |>
  mutate(column = match(column, names(Z))    # Replace 'column' with number; oxylipid = 1, enzyme=2, FA=3
         ) |>
  group_by(row) |>                           # Specify that rows indicate columns are related
  mutate(target = lead(source,               # Create target variable which specifies the second node
                       order_by = column)    # This creates a 3-tier system (oxylipid->Enzyme->FA)
         ) |>
  filter(!is.na(target)) |>                  # remove row if 'NA' is the second node              
  ungroup()      

# Append 'column' to the source and target variables
links.df <-
  links.df |>
  mutate(source = paste0(source, '_', column)) |>
  mutate(target = paste0(target, '_', column + 1)) |> # target is the same as the 
  select(row, column, source, target)                 # source for the next column 

# Specify the main 'nodes' within the three tiers (i.e. Enzymatic groups and individual FA in those tiers)
nodes.df <- data.frame(name = unique(c(links.df$source, 
                                       links.df$target)
                                     )
                       )

# Create column with label for each node above
nodes.df$label <- sub('_[0-9]*$', '',
                      nodes.df$name) 

# Create network pattern
links.df$source_id <- match(links.df$source, nodes.df$name) - 1 # Create source_id column
links.df$target_id <- match(links.df$target, nodes.df$name) - 1 # Create target_id column
links.df$value <- 1                                       # Assign link values (width same for all lines)

# Make the plot
p0 <- sankeyNetwork(Links = links.df, # How everything is connected
              Nodes = nodes.df,     # major nodes 
              Source = 'source_id', # Start of segment
              Target = 'target_id', # End of segment
              Value = 'value',      # size of line
              NodeID = 'label',     # name of each major node
              fontFamily = "sans",  
              fontSize = 16,        
              iterations = 0)       # prevent diagram layout changes

# Save html of Sankey
saveWidget(p0, file="output/Sankey_oxylipid.html")

# Create .pdf from .html output
webshot("output/Sankey_oxylipid.html", 
        file="output/Sankey_oxylipid.pdf")
```

------------------------------------------------------------------------

# 7. System info 
```{r}
sessionInfo()
```
R version 4.2.2 (2022-10-31)
Platform: x86_64-apple-darwin17.0 (64-bit)
Running under: macOS Monterey 12.6.2

Matrix products: default
LAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] parallel  grid      stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] doParallel_1.0.17   iterators_1.0.14    foreach_1.5.2       webshot_0.5.4      
 [5] htmlwidgets_1.6.0   networkD3_0.4       DescTools_0.99.47   vip_0.3.2          
 [9] broom.mixed_0.2.9.4 yardstick_1.1.0     workflowsets_1.0.0  workflows_1.1.2    
[13] tune_1.0.1          rsample_1.1.1       recipes_1.0.3       parsnip_1.0.3      
[17] modeldata_1.0.1     infer_1.0.4         dials_1.1.0         broom_1.0.2        
[21] tidymodels_1.0.0    glmnet_4.1-6        Matrix_1.5-3        VennDiagram_1.7.3  
[25] futile.logger_1.4.3 corrplot_0.92       ggrepel_0.9.2       RColorBrewer_1.1-3 
[29] Cairo_1.6-0         scales_1.2.1        ggsci_2.9           rstatix_0.7.1      
[33] ggpubr_0.5.0        forcats_0.5.2       stringr_1.5.0       dplyr_1.0.10       
[37] purrr_0.3.5         readr_2.1.3         tidyr_1.2.1         tibble_3.1.8       
[41] ggplot2_3.4.0       tidyverse_1.3.2    

loaded via a namespace (and not attached):
  [1] readxl_1.4.1         backports_1.4.1      igraph_1.3.5         splines_4.2.2       
  [5] listenv_0.9.0        digest_0.6.31        htmltools_0.5.4      fansi_1.0.3         
  [9] magrittr_2.0.3       googlesheets4_1.0.1  tzdb_0.3.0           globals_0.16.2      
 [13] modelr_0.1.10        gower_1.0.1          vroom_1.6.0          hardhat_1.2.0       
 [17] timechange_0.1.1     colorspace_2.0-3     rvest_1.0.3          haven_2.5.1         
 [21] xfun_0.35.3          callr_3.7.3          crayon_1.5.2         jsonlite_1.8.4      
 [25] Exact_3.2            survival_3.4-0       glue_1.6.2           gtable_0.3.1        
 [29] gargle_1.2.1         ipred_0.9-13         car_3.1-1            future.apply_1.10.0 
 [33] shape_1.4.6          abind_1.4-5          futile.options_1.0.1 mvtnorm_1.1-3       
 [37] DBI_1.1.3            Rcpp_1.0.9           bit_4.0.5            GPfit_1.0-8         
 [41] proxy_0.4-27         lava_1.7.0           prodlim_2019.11.13   httr_1.4.4          
 [45] ellipsis_0.3.2       farver_2.1.1         pkgconfig_2.0.3      nnet_7.3-18         
 [49] dbplyr_2.2.1         utf8_1.2.2           labeling_0.4.2       tidyselect_1.2.0    
 [53] rlang_1.0.6          DiceDesign_1.9       munsell_0.5.0        cellranger_1.1.0    
 [57] tools_4.2.2          cli_3.4.1            generics_0.1.3       evaluate_0.19       
 [61] fastmap_1.1.0        yaml_2.3.6           processx_3.8.0       bit64_4.0.5         
 [65] knitr_1.41           fs_1.5.2             rootSolve_1.8.2.3    future_1.30.0       
 [69] nlme_3.1-161         formatR_1.13         xml2_1.3.3           compiler_4.2.2      
 [73] rstudioapi_0.14      e1071_1.7-12         ggsignif_0.6.4       reprex_2.0.2        
 [77] lhs_1.1.6            stringi_1.7.8        ps_1.7.2             lattice_0.20-45     
 [81] vctrs_0.5.1          pillar_1.8.1         lifecycle_1.0.3      furrr_0.3.1         
 [85] data.table_1.14.6    lmom_2.9             R6_2.5.1             gridExtra_2.3       
 [89] parallelly_1.33.0    gld_2.6.6            codetools_0.2-18     lambda.r_1.2.4      
 [93] boot_1.3-28.1        MASS_7.3-58.1        assertthat_0.2.1     withr_2.5.0         
 [97] mgcv_1.8-41          expm_0.999-6         hms_1.1.2            rpart_4.1.19        
[101] timeDate_4021.107    class_7.3-20         rmarkdown_2.19       carData_3.0-5       
[105] googledrive_2.0.0    lubridate_1.9.0  